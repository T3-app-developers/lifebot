<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Lifebot Town</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    #renderCanvas { width: 100%; height: 100%; }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 4px 8px;
      border-radius: 4px;
    }

    .elevator-panel {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 8px;
      color: white;
      font-family: sans-serif;
    }
    .elevator-panel button {
      margin: 4px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .level-label {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.8);
      padding: 6px 12px;
      border-radius: 6px;
      font-family: sans-serif;
      font-weight: bold;
    }

  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <div id="ui">Coins: <span id="coinCount">0</span></div>
  <div id="message" style="display:none;position:absolute;top:40px;left:10px;color:white;font-family:sans-serif;background:rgba(0,0,0,0.7);padding:4px 8px;border-radius:4px;"></div>
  <div class="level-label" id="levelLabel">Level 1</div>
  <div class="elevator-panel" id="elevatorPanel">
    <div>Elevator:</div>
    <button data-target="1">1</button>
    <button data-target="2">2</button>
    <button data-target="3">3</button>
  </div>

  <script>
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);

    const gameState = { coins: 10, heldItem: null };
    const coinEl = document.getElementById('coinCount');

    const messageEl = document.getElementById('message');
    function updateCoinsUI(){
      coinEl.textContent = gameState.coins;
    }
    function showMessage(msg){
      messageEl.textContent = msg;
      messageEl.style.display = 'block';
      clearTimeout(showMessage._t);
      showMessage._t = setTimeout(()=>{messageEl.style.display='none';}, 2000);
    }

    function buildHouse(name, x, scene, mats) {

      const house = new BABYLON.TransformNode(name, scene);
      const size = 4;
      const height = 3;
      const t = 0.1;
      const doorWidth = 1.5;
      const doorHeight = 2.2;

      const floor = BABYLON.MeshBuilder.CreateBox(name+'Floor', {width:size, depth:size, height:t}, scene);
      floor.position.y = t/2;
      floor.material = mats.brick;

      floor.parent = house;

      const roof = BABYLON.MeshBuilder.CreateBox(name+'Roof', {width:size, depth:size, height:t}, scene);
      roof.position.y = height + t/2;

      roof.material = mats.brick;

      roof.parent = house;

      const back = BABYLON.MeshBuilder.CreateBox(name+'Back', {width:size, height:height, depth:t}, scene);
      back.position.set(0, height/2, -size/2 + t/2);

      back.material = mats.brick;

      back.parent = house;

      const left = BABYLON.MeshBuilder.CreateBox(name+'Left', {width:t, height:height, depth:size}, scene);
      left.position.set(-size/2 + t/2, height/2, 0);

      left.material = mats.brick;

      left.parent = house;

      const right = BABYLON.MeshBuilder.CreateBox(name+'Right', {width:t, height:height, depth:size}, scene);
      right.position.set(size/2 - t/2, height/2, 0);

      right.material = mats.brick;

      right.parent = house;

      const sideWidth = (size - doorWidth)/2;
      const frontLeft = BABYLON.MeshBuilder.CreateBox(name+'FrontLeft', {width:sideWidth, height:height, depth:t}, scene);
      frontLeft.position.set(-doorWidth/2 - sideWidth/2, height/2, size/2 - t/2);

      frontLeft.material = mats.brick;

      frontLeft.parent = house;

      const frontRight = BABYLON.MeshBuilder.CreateBox(name+'FrontRight', {width:sideWidth, height:height, depth:t}, scene);
      frontRight.position.set(doorWidth/2 + sideWidth/2, height/2, size/2 - t/2);

      frontRight.material = mats.brick;

      frontRight.parent = house;

      const topH = height - doorHeight;
      const frontTop = BABYLON.MeshBuilder.CreateBox(name+'FrontTop', {width:doorWidth, height:topH, depth:t}, scene);
      frontTop.position.set(0, doorHeight + topH/2, size/2 - t/2);

      frontTop.material = mats.brick;

      frontTop.parent = house;

      const bed = BABYLON.MeshBuilder.CreateBox(name+'Bed', {width:1.5, height:0.5, depth:2}, scene);
      bed.position.set(-1.2, 0.25, -0.8);

      bed.material = mats.brick;

      bed.parent = house;

      const sink = BABYLON.MeshBuilder.CreateBox(name+'Sink', {width:1, height:0.6, depth:0.5}, scene);
      sink.position.set(1.2, 0.3, -1.5);
      sink.isPickable = true;

      sink.material = mats.metal;

      sink.parent = house;

      const faucet = BABYLON.MeshBuilder.CreateBox(name+'Faucet', {width:0.1, height:0.1, depth:0.4}, scene);
      faucet.position.set(0, 0.35, -0.25);
      faucet.material = mats.metal;
      faucet.parent = sink;

      const water = BABYLON.MeshBuilder.CreateCylinder(name+'Water', {diameter:0.1, height:0.3}, scene);
      water.position.set(0, 0.15, -0.4);
      water.material = mats.water;
      water.parent = sink;
      water.scaling.y = 0;

      const anim = new BABYLON.Animation(name+'Tap', 'rotation.z', 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
      anim.setKeys([
        {frame:0, value:0},
        {frame:15, value:Math.PI/2},
        {frame:30, value:0}
      ]);

      const waterAnim = new BABYLON.Animation(name+'WaterAnim', 'scaling.y', 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
      waterAnim.setKeys([
        {frame:0, value:0},
        {frame:10, value:1},
        {frame:20, value:1},
        {frame:30, value:0}
      ]);

      faucet.animations = [anim];
      water.animations = [waterAnim];
      sink.actionManager = new BABYLON.ActionManager(scene);
      sink.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, function(){
        scene.beginAnimation(faucet, 0, 30, false);
        scene.beginAnimation(water, 0, 30, false);

      }));

      house.position.x = x;
    }

    function buildShop(name, position, scene, mats) {
      const shop = new BABYLON.TransformNode(name, scene);

      const size = 4;
      const box = BABYLON.MeshBuilder.CreateBox(name+'Box', {width:size, depth:size, height:3}, scene);
      box.position.y = 1.5;
      box.material = mats.brick;
      box.parent = shop;

      // create items on a simple shelf
      const items = [];
      for(let i=0;i<3;i++){
        const itm = BABYLON.MeshBuilder.CreateSphere(name+'Item'+i, {diameter:0.5}, scene);
        itm.position.set(-1 + i*1, 1.2, 0);
        itm.material = mats.metal;
        itm.isPickable = true;
        itm.metadata = {price:5+i*2, index:i};
        itm.parent = shop;
        items.push(itm);
      }

      // checkout till
      const till = BABYLON.MeshBuilder.CreateBox(name+'Till', {width:1.5, depth:1, height:1}, scene);
      till.position.set(0,0.5,size/2 - 0.6);
      till.material = mats.metal;
      till.isPickable = false;
      till.parent = shop;

      shop.position.copyFrom(position);
      shop.items = items;
      shop.till = till;

      return shop;
    }

    function buildFlameBot(name, scene) {
      const bot = new BABYLON.TransformNode(name, scene);

      const box = BABYLON.MeshBuilder.CreateBox(name + 'Body', {size: 2}, scene);
      box.position.y = 1;
      const boxMat = new BABYLON.StandardMaterial(name + 'BodyMat', scene);
      boxMat.diffuseColor = new BABYLON.Color3(1, 0, 0);
      box.material = boxMat;
      box.parent = bot;

      function createArm(n, x, y, z, rx, ry, rz) {
        const arm = BABYLON.MeshBuilder.CreateCylinder(n, {
          height: 1.5,
          diameterTop: 0.2,
          diameterBottom: 0.2,
          tessellation: 12
        }, scene);
        arm.position = new BABYLON.Vector3(x, y, z);
        arm.rotation = new BABYLON.Vector3(rx, ry, rz);
        const mat = new BABYLON.StandardMaterial(n + 'Mat', scene);
        mat.diffuseColor = new BABYLON.Color3(0.8, 0.6, 0.4);
        arm.material = mat;
        arm.parent = bot;
        return arm;
      }

      function createFlamethrower(parentArm) {
        const barrel = BABYLON.MeshBuilder.CreateCylinder('barrel', {
          height: 1,
          diameterTop: 0.1,
          diameterBottom: 0.1,
          tessellation: 12
        }, scene);
        barrel.parent = parentArm;
        barrel.position = new BABYLON.Vector3(0.6, -0.2, 0.1);
        barrel.rotation = new BABYLON.Vector3(0, 0, Math.PI / 2);
        const barrelMat = new BABYLON.StandardMaterial('barrelMat', scene);
        barrelMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
        barrel.material = barrelMat;

        const tank = BABYLON.MeshBuilder.CreateBox('tank', {size: 0.4}, scene);
        tank.parent = parentArm;
        tank.position = new BABYLON.Vector3(0.2, -0.4, -0.1);
        const tankMat = new BABYLON.StandardMaterial('tankMat', scene);
        tankMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        tank.material = tankMat;

        const fire = new BABYLON.ParticleSystem('fire', 2000, scene);
        fire.particleTexture = new BABYLON.Texture('https://assets.babylonjs.com/particles/flare.png', scene);
        fire.emitter = barrel;
        fire.minEmitBox = new BABYLON.Vector3(0.5, 0, 0);
        fire.maxEmitBox = new BABYLON.Vector3(0.6, 0, 0);
        fire.color1 = new BABYLON.Color4(1, 0.5, 0, 1);
        fire.color2 = new BABYLON.Color4(1, 0.2, 0, 1);
        fire.minSize = 0.1;
        fire.maxSize = 0.3;
        fire.minLifeTime = 0.2;
        fire.maxLifeTime = 0.5;
        fire.emitRate = 500;
        fire.direction1 = new BABYLON.Vector3(1, 0, 0);
        fire.direction2 = new BABYLON.Vector3(1, 0.2, 0);
        fire.gravity = new BABYLON.Vector3(0, -1, 0);
        fire.start();
      }

      const leftArm = createArm('leftArm', -1.1, 1.5, 0, 0, 0, Math.PI / 2);
      const rightArm = createArm('rightArm', 1.1, 1.5, 0, 0, 0, Math.PI / 2);
      createFlamethrower(rightArm);

      function createLeg(n, x, y, z) {
        const leg = BABYLON.MeshBuilder.CreateCylinder(n, {
          height: 2,
          diameterTop: 0.3,
          diameterBottom: 0.3,
          tessellation: 12
        }, scene);
        leg.position = new BABYLON.Vector3(x, y, z);
        const legMat = new BABYLON.StandardMaterial(n + 'Mat', scene);
        legMat.diffuseColor = new BABYLON.Color3(0.8, 0.6, 0.4);
        leg.material = legMat;
        leg.parent = bot;
      }
      createLeg('leftLeg', -0.5, 0, 0);
      createLeg('rightLeg', 0.5, 0, 0);

      function createEye(n, x, y, z) {
        const eye = BABYLON.MeshBuilder.CreateSphere(n, {diameter: 0.3}, scene);
        eye.position = new BABYLON.Vector3(x, y, z);
        const eyeMat = new BABYLON.StandardMaterial(n + 'Mat', scene);
        eyeMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
        eye.material = eyeMat;
        eye.parent = bot;

        const pupil = BABYLON.MeshBuilder.CreateSphere(n + 'Pupil', {diameter: 0.15}, scene);
        pupil.position = new BABYLON.Vector3(x, y, z + 0.18);
        const pMat = new BABYLON.StandardMaterial(n + 'PupilMat', scene);
        pMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
        pupil.material = pMat;
        pupil.parent = bot;

        const laser = BABYLON.MeshBuilder.CreateCylinder(n + 'Laser', {
          height: 5,
          diameterTop: 0.05,
          diameterBottom: 0.05,
          tessellation: 6
        }, scene);
        laser.parent = eye;
        laser.position = new BABYLON.Vector3(0, 0, 2.5);
        laser.rotation.x = Math.PI / 2;
        const laserMat = new BABYLON.StandardMaterial(n + 'LaserMat', scene);
        laserMat.emissiveColor = new BABYLON.Color3(1, 0, 0);
        laser.material = laserMat;
      }
      createEye('leftEye', -0.5, 1.25, 1.01);
      createEye('rightEye', 0.5, 1.25, 1.01);

      const mouth = BABYLON.MeshBuilder.CreateTorus('mouth', {
        diameter: 0.8,
        thickness: 0.08,
        tessellation: 32
      }, scene);
      mouth.position = new BABYLON.Vector3(0, 0.85, 1.01);
      mouth.rotation.x = Math.PI / 2;
      mouth.rotation.z = Math.PI;
      const mouthMat = new BABYLON.StandardMaterial('mouthMat', scene);
      mouthMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
      mouth.material = mouthMat;
      mouth.parent = bot;

      return bot;
    }

    function buildSkyscraper(scene, camera) {
      const STORY_HEIGHT = 3;
      const LEVEL_POSITIONS = {
        1: new BABYLON.Vector3(0, 1.5, 0),
        2: new BABYLON.Vector3(0, STORY_HEIGHT + 1.5, 0),
        3: new BABYLON.Vector3(0, STORY_HEIGHT * 2 + 1.5, 0)
      };
      const root = new BABYLON.TransformNode('skyscraper', scene);

      const whiteMat = new BABYLON.StandardMaterial('whiteMat', scene);
      whiteMat.diffuseColor = new BABYLON.Color3(1, 1, 1);

      const building = BABYLON.MeshBuilder.CreateBox('building', {height: STORY_HEIGHT * 6, width: 10, depth: 10}, scene);
      building.position.y = (STORY_HEIGHT * 6) / 2;
      building.material = whiteMat;
      building.isPickable = false;
      building.checkCollisions = false;
      building.parent = root;

      for (let i = 0; i < 6; i++) {
        const floor = BABYLON.MeshBuilder.CreateBox(`floor${i + 1}`, {width: 9.8, depth: 9.8, height: 0.1}, scene);
        floor.position.y = i * STORY_HEIGHT + 0.05;
        floor.material = whiteMat;
        floor.checkCollisions = true;
        floor.parent = root;
      }

      for (let i = 0; i < 3; i++) {
        const ceiling = BABYLON.MeshBuilder.CreateBox(`ceiling${i + 1}`, {width: 9.8, depth: 9.8, height: 0.1}, scene);
        ceiling.position.y = i * STORY_HEIGHT + STORY_HEIGHT - 0.05;
        ceiling.material = whiteMat;
        ceiling.checkCollisions = true;
        ceiling.parent = root;
      }

      const blueMat = new BABYLON.StandardMaterial('blueMat', scene);
      blueMat.diffuseColor = new BABYLON.Color3(0.1, 0.4, 1);
      const doorFrame = BABYLON.MeshBuilder.CreateBox('frontDoorFrame', {width: 2, height: 2.5, depth: 0.2}, scene);
      doorFrame.position = new BABYLON.Vector3(0, 1.25, 5.1);
      doorFrame.material = blueMat;
      doorFrame.parent = root;

      const blackMat = new BABYLON.StandardMaterial('blackMat', scene);
      blackMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
      const midLine = BABYLON.MeshBuilder.CreateBox('doorLine', {width: 0.1, height: 2.5, depth: 0.25}, scene);
      midLine.position = new BABYLON.Vector3(0, 1.25, 5.2);
      midLine.material = blackMat;
      midLine.parent = root;

      const shaft = BABYLON.MeshBuilder.CreateBox('shaft', {width: 2, height: STORY_HEIGHT * 3 + 0.1, depth: 2}, scene);
      shaft.position.y = (STORY_HEIGHT * 3) / 2;
      shaft.position.x = 3;
      const shaftMat = new BABYLON.StandardMaterial('shaftMat', scene);
      shaftMat.alpha = 0.1;
      shaft.material = shaftMat;
      shaft.isPickable = false;
      shaft.parent = root;

      const elevatorPad = BABYLON.MeshBuilder.CreateBox('elevatorPad', {width: 1.5, depth: 1.5, height: 0.1}, scene);
      elevatorPad.position = new BABYLON.Vector3(3, 1.5, 0);
      const padMat = new BABYLON.StandardMaterial('padMat', scene);
      padMat.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);
      elevatorPad.material = padMat;
      elevatorPad.checkCollisions = false;
      elevatorPad.parent = root;

      const panel = BABYLON.MeshBuilder.CreatePlane('panel', {width: 0.6, height: 1}, scene);
      panel.position = new BABYLON.Vector3(2.2, 1.5, 0);
      panel.rotation.y = Math.PI / 2;
      const panelMat = new BABYLON.StandardMaterial('panelMat', scene);
      panelMat.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
      panel.material = panelMat;
      panel.parent = root;

      function createLevel1Contents() {
        const desk = BABYLON.MeshBuilder.CreateBox('desk1', {width: 2, depth: 1, height: 0.2}, scene);
        desk.position = new BABYLON.Vector3(-2, 1, 2);
        desk.parent = root;
        const leg1 = BABYLON.MeshBuilder.CreateBox('deskLeg1', {width: 0.2, depth: 0.2, height: 1}, scene);
        leg1.position = new BABYLON.Vector3(-3, 0.5, 2);
        leg1.parent = root;
        const leg2 = leg1.clone('deskLeg2');
        leg2.position.x = -1;
        const chair = BABYLON.MeshBuilder.CreateCylinder('chair1', {diameter: 0.8, height: 0.5}, scene);
        chair.position = new BABYLON.Vector3(-2, 0.5, 1);
        chair.parent = root;
      }

      function createLevel2Contents() {
        const glassMat = new BABYLON.StandardMaterial('glass', scene);
        glassMat.alpha = 0.2;
        glassMat.diffuseColor = new BABYLON.Color3(0.4, 0.7, 1);
        glassMat.specularColor = new BABYLON.Color3(1, 1, 1);
        const window2 = BABYLON.MeshBuilder.CreatePlane('window2', {width: 6, height: 3}, scene);
        window2.position = new BABYLON.Vector3(0, STORY_HEIGHT + 1.5, -4.9);
        window2.material = glassMat;
        window2.parent = root;

        const counter = BABYLON.MeshBuilder.CreateBox('kitchenCounter2', {width: 2.5, depth: 1, height: 1}, scene);
        counter.position = new BABYLON.Vector3(3, STORY_HEIGHT + 0.5, -3);
        counter.parent = root;
        const stove = BABYLON.MeshBuilder.CreateBox('stove2', {width: 1, depth: 1, height: 0.5}, scene);
        stove.position = new BABYLON.Vector3(3, STORY_HEIGHT + 0.75, -1.5);
        stove.parent = root;

        const bedBase = BABYLON.MeshBuilder.CreateBox('bed2', {width: 2, depth: 3, height: 0.5}, scene);
        bedBase.position = new BABYLON.Vector3(-3, STORY_HEIGHT + 0.25, -3);
        bedBase.parent = root;
        const pillow = BABYLON.MeshBuilder.CreateBox('pillow2', {width: 1.8, depth: 0.5, height: 0.2}, scene);
        pillow.position = new BABYLON.Vector3(-3, STORY_HEIGHT + 0.5, -1.5);
        pillow.parent = root;

        const couchBase = BABYLON.MeshBuilder.CreateBox('couch2', {width: 3, depth: 1, height: 1}, scene);
        couchBase.position = new BABYLON.Vector3(-3, STORY_HEIGHT + 0.5, 2);
        couchBase.parent = root;
        const cushion = BABYLON.MeshBuilder.CreateBox('cushion2', {width: 2.8, depth: 0.8, height: 0.4}, scene);
        cushion.position = new BABYLON.Vector3(-3, STORY_HEIGHT + 0.7, 2);
        cushion.parent = root;
      }

      function createLevel3Contents() {
        const glassMat3 = new BABYLON.StandardMaterial('glass3', scene);
        glassMat3.alpha = 0.2;
        glassMat3.diffuseColor = new BABYLON.Color3(0.4, 0.7, 1);
        glassMat3.specularColor = new BABYLON.Color3(1, 1, 1);
        const window3 = BABYLON.MeshBuilder.CreatePlane('window3', {width: 6, height: 3}, scene);
        window3.position = new BABYLON.Vector3(0, STORY_HEIGHT * 2 + 1.5, -4.9);
        window3.material = glassMat3;
        window3.parent = root;

        const desk3 = BABYLON.MeshBuilder.CreateBox('desk3', {width: 2.5, depth: 1.2, height: 0.3}, scene);
        desk3.position = new BABYLON.Vector3(-3, STORY_HEIGHT * 2 + 1.2, 2);
        desk3.parent = root;
        const chair3 = BABYLON.MeshBuilder.CreateBox('officeChair3', {width: 1, depth: 1, height: 1.5}, scene);
        chair3.position = new BABYLON.Vector3(-3, STORY_HEIGHT * 2 + 0.75, 0.5);
        chair3.parent = root;
        const monitor = BABYLON.MeshBuilder.CreateBox('monitor3', {width: 1, depth: 0.1, height: 0.6}, scene);
        monitor.position = new BABYLON.Vector3(-3, STORY_HEIGHT * 2 + 1.5, 2);
        monitor.parent = root;
        const keyboard = BABYLON.MeshBuilder.CreateBox('keyboard3', {width: 1.5, depth: 0.2, height: 0.05}, scene);
        keyboard.position = new BABYLON.Vector3(-3, STORY_HEIGHT * 2 + 1.05, 1.5);
        keyboard.parent = root;

        const counter3 = BABYLON.MeshBuilder.CreateBox('kitchenCounter3', {width: 2, depth: 1, height: 1}, scene);
        counter3.position = new BABYLON.Vector3(3, STORY_HEIGHT * 2 + 0.5, -3);
        counter3.parent = root;
        const stove3 = BABYLON.MeshBuilder.CreateBox('stove3', {width: 1, depth: 1, height: 0.5}, scene);
        stove3.position = new BABYLON.Vector3(3, STORY_HEIGHT * 2 + 0.75, -1.5);
        stove3.parent = root;
      }

      createLevel1Contents();
      createLevel2Contents();
      createLevel3Contents();

      function teleportToLevel(lvl) {
        const target = LEVEL_POSITIONS[lvl].add(root.position);
        camera.position = target.clone();
        document.getElementById('levelLabel').innerText = `Level ${lvl}`;
      }

      document.querySelectorAll('.elevator-panel button').forEach(btn => {
        btn.addEventListener('click', () => {
          const lvl = parseInt(btn.dataset.target);
          teleportToLevel(lvl);
        });
      });

      root.position = new BABYLON.Vector3(20, 0, 32);
      teleportToLevel(1);
    }

    const createScene = function() {
    const scene = new BABYLON.Scene(engine);

    const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.2, 0.8, 0.2);

    const brickMat = new BABYLON.StandardMaterial('brickMat', scene);
    brickMat.diffuseColor = new BABYLON.Color3(0.8, 0.3, 0.3);

    const metalMat = new BABYLON.StandardMaterial('metalMat', scene);
    metalMat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);

    const waterMat = new BABYLON.StandardMaterial('waterMat', scene);
    waterMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 1);
    waterMat.alpha = 0.7;

    const sandMat = new BABYLON.StandardMaterial('sandMat', scene);
    sandMat.diffuseColor = new BABYLON.Color3(0.94, 0.86, 0.67);

    const mats = { brick: brickMat, metal: metalMat, water: waterMat, ground: groundMat, sand: sandMat };

    function createTrafficLight(name, position){
      const pole = BABYLON.MeshBuilder.CreateCylinder(name+'Pole', {diameter:0.2, height:3}, scene);
      pole.position = new BABYLON.Vector3(position.x, 1.5, position.z);
      pole.material = metalMat;

      const box = BABYLON.MeshBuilder.CreateBox(name+'Box', {width:0.5, height:0.5, depth:0.5}, scene);
      box.position = new BABYLON.Vector3(position.x, 2.5, position.z);
      box.material = metalMat;

      const redMat = new BABYLON.StandardMaterial(name+'RedMat', scene);
      redMat.emissiveColor = new BABYLON.Color3(1, 0, 0);
      const greenMat = new BABYLON.StandardMaterial(name+'GreenMat', scene);
      greenMat.emissiveColor = new BABYLON.Color3(0, 0.3, 0);

      const red = BABYLON.MeshBuilder.CreateSphere(name+'Red', {diameter:0.2}, scene);
      red.position = new BABYLON.Vector3(position.x, 2.5, position.z+0.3);
      red.material = redMat;

      const green = BABYLON.MeshBuilder.CreateSphere(name+'Green', {diameter:0.2}, scene);
      green.position = new BABYLON.Vector3(position.x, 2.1, position.z+0.3);
      green.material = greenMat;

      let state = 0;
      setInterval(() => {
        state = 1 - state;
        if (state) {
          redMat.emissiveColor.set(0.3, 0, 0);
          greenMat.emissiveColor.set(0, 1, 0);
        } else {
          redMat.emissiveColor.set(1, 0, 0);
          greenMat.emissiveColor.set(0, 0.3, 0);
        }
      }, 3000);
    }

      const camera = new BABYLON.UniversalCamera('player', new BABYLON.Vector3(0, 1.7, -10), scene);
      camera.attachControl(canvas, true);
      camera.speed = 0.25;

      scene.onPointerDown = function(){
        if(!document.pointerLockElement){
          canvas.requestPointerLock();
        }
      };

    new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);

    const ocean = BABYLON.MeshBuilder.CreateGround('ocean', {width:3600, height:3600}, scene);
    ocean.position.y = -0.1;
    ocean.material = waterMat;

    const beach = BABYLON.MeshBuilder.CreateGround('beach', {width:70, height:70}, scene);
    beach.position.y = -0.05;
    beach.material = sandMat;

    const ground = BABYLON.MeshBuilder.CreateGround('ground', {width:60, height:60}, scene);
    ground.position.y = 0;
    ground.material = groundMat;

    const frontLot = BABYLON.MeshBuilder.CreateGround('frontLot', {width:60, height:80}, scene);
    frontLot.position = new BABYLON.Vector3(20, 0, 75);
    frontLot.material = groundMat;

    const roadMat = new BABYLON.StandardMaterial('roadMat', scene);
    roadMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);

      buildHouse('house1', -6, scene, mats);
      buildHouse('house2', 0, scene, mats);
      buildHouse('house3', 6, scene, mats);

      buildSkyscraper(scene, camera);

      const roadFront = BABYLON.MeshBuilder.CreateGround('roadFront', {width:32, height:4}, scene);
      roadFront.position = new BABYLON.Vector3(0, 0.01, 12);
      roadFront.material = roadMat;

      const roadBack = BABYLON.MeshBuilder.CreateGround('roadBack', {width:32, height:4}, scene);
      roadBack.position = new BABYLON.Vector3(0, 0.01, -4);
      roadBack.material = roadMat;

      const roadLeft = BABYLON.MeshBuilder.CreateGround('roadLeft', {width:4, height:20}, scene);
      roadLeft.position = new BABYLON.Vector3(-16, 0.01, 4);
      roadLeft.material = roadMat;

      const mainRoad = BABYLON.MeshBuilder.CreateGround('mainRoad', {width:4, height:150}, scene);
      mainRoad.position = new BABYLON.Vector3(14, 0.01, 50);
      mainRoad.material = roadMat;

      const skyBack = BABYLON.MeshBuilder.CreateGround('skyBack', {width:12, height:4}, scene);
      skyBack.position = new BABYLON.Vector3(20, 0.01, 25);
      skyBack.material = roadMat;

      const skyFront = BABYLON.MeshBuilder.CreateGround('skyFront', {width:12, height:4}, scene);
      skyFront.position = new BABYLON.Vector3(20, 0.01, 39);
      skyFront.material = roadMat;

      const skyRight = BABYLON.MeshBuilder.CreateGround('skyRight', {width:4, height:14}, scene);
      skyRight.position = new BABYLON.Vector3(26, 0.01, 32);
      skyRight.material = roadMat;

      createTrafficLight('tl1', new BABYLON.Vector3(14, 0, 12));
      createTrafficLight('tl2', new BABYLON.Vector3(14, 0, 39));

      // load car model and place it behind the houses
      BABYLON.SceneLoader.ImportMesh("", "assets/", "brio_psx_style_han66st.glb", scene, function(meshes){
        const car = meshes[0];
        // put the car behind the houses so it is visible from the starting point
        car.position.set(2, 0, -4);
        car.scaling.scaleInPlace(0.5);
      });

      const shop = buildShop('shop', new BABYLON.Vector3(0, 0, 8), scene, mats);
      shop.items.forEach(item => {
        item.actionManager = new BABYLON.ActionManager(scene);
        item.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, function(){
          if(!gameState.heldItem){
            gameState.heldItem = item;
            item.setParent(camera);
            item.position.set(0.5, -0.5, 1);
          }
        }));
      });

      const bot = buildFlameBot('bot', scene);
      bot.position.set(shop.position.x + 3, 0, shop.position.z);

      scene.onBeforeRenderObservable.add(()=>{
        if(gameState.heldItem){
          const dist = BABYLON.Vector3.Distance(gameState.heldItem.getAbsolutePosition(), shop.till.getAbsolutePosition());
          if(dist < 1.2 && !gameState.processingSale){
            gameState.processingSale = true;
            const price = gameState.heldItem.metadata.price;
            showMessage("That'll be " + price + " coins, please!");
            if(gameState.coins >= price){
              gameState.coins -= price;
              updateCoinsUI();
              showMessage("Purchased!");
              gameState.heldItem.dispose();
              gameState.heldItem = null;
            } else {
              showMessage("You don't have enough coins.");
              gameState.heldItem.setParent(shop);
              gameState.heldItem.position.set(-1 + gameState.heldItem.metadata.index*1, 1.2, 0);
              gameState.heldItem = null;
            }
            setTimeout(()=>{gameState.processingSale=false;},1000);
          }
        }
      });


      updateCoinsUI();

      return scene;
    };

    const scene = createScene();

    engine.runRenderLoop(function () {
      scene.render();
    });

    window.addEventListener('resize', function () {
      engine.resize();
    });
  </script>
</body>
</html>
